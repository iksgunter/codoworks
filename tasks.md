## standart

#### Этап 3

###### Задание 1: Простая фильтрация

Цель: Вывести список заказов клиента с конкретным именем (например, "Иван Иванов").
Ожидаемый результат: Таблица с колонками id, order_date, где каждая строка — это один заказ нужного клиента.  

###### Задание 2: Фильтрация + сортировка
Цель: Получить список всех товаров из конкретного заказа (например, заказ с ID = 3), отсортированный по цене по убыванию.
Ожидаемый результат: Таблица с колонками product_name, quantity, price, отсортированная по убыванию цены.

###### Задание 3: Группировка + фильтрация
Цель: Вывести список клиентов и общую сумму, которую они потратили во всех заказах. Показать только тех клиентов, у кого сумма покупок больше 5000.
Ожидаемый результат: Таблица с колонками name, total_spent, где total_spent — это сумма (цена × количество) всех товаров во всех заказах клиента. Должны отображаться только клиенты, у которых total_spent > 5000.
Цель: Вывести список заказов клиента с конкретным именем (например, "Иван Иванов"). Ожидаемый результат: Таблица с колонками id, order_date, где каждая строка — это один заказ нужного клиента.

###### Задание 2: Фильтрация + сортировка
Цель: Получить список всех товаров из конкретного заказа (например, заказ с ID = 3), отсортированный по цене по убыванию. Ожидаемый результат: Таблица с колонками product_name, quantity, price, отсортированная по убыванию цены.

###### Задание 3: Группировка + фильтрация
Цель: Вывести список клиентов и общую сумму, которую они потратили во всех заказах. Показать только тех клиентов, у кого сумма покупок больше 5000. Ожидаемый результат: Таблица с колонками name, total_spent, где total_spent — это сумма (цена × количество) всех товаров во всех заказах клиента. Должны отображаться только клиенты, у которых total_spent > 5000.



## idx_tran

#### Этап 1: Массовое наполнение базы
Цель: Сымитировать работу интернет-магазина с большим количеством данных.
Требование:
	- Заполнить таблицу order_items минимум 1 000 000 строк.
	- Данные должны быть осмысленными (разные товары, случайные цены, количества, ссылки на реальные заказы).
	- При необходимости используйте генераторы или скрипты (например, INSERT ... SELECT, generate_series, Python-скрипты и пр.).  
Пример ожидаемого результата:
	- Таблица order_items содержит миллион записей, где product_name варьируется (например, "Товар 1"–"Товар 500"), price в диапазоне от 100 до 100 000, quantity — от 1 до 10.

#### Этап 2: Установка индексов
Цель: Ускорить выполнение часто используемых запросов.
Требования:
- Создать следующие индексы:  
	1. По полю customer_id в таблице orders;
	2. Композитный индекс по (order_id, price) в таблице order_items;
	3. Индекс по product_name в таблице order_items (если предполагается частый поиск по названию товара).

#### Этап 3: Анализ использования индексов
Цель: Проверить, используется ли индекс при выполнении запроса.
Требования:
- Написать EXPLAIN ANALYZE для запроса, который ищет: 
	1. Все товары с price > 10000 из заказа с ID = 123.
	2. Все заказы клиента с customer_id = 1.     
Ожидаемый результат:
	- План выполнения показывает использование соответствующего индекса (например, Index Scan по order_items(order_id, price)).
	- При необходимости внести корректировки в индексы.

#### Этап 4: Удаление неэффективных индексов
Цель: Очищать ненужные или неиспользуемые ресурсы.
Требование:
	- Удалить индекс, если по результатам EXPLAIN ANALYZE он не используется или ухудшает производительность.
	- Указать, почему индекс был удалён.

#### Этап 5: Бизнес-логика с использованием транзакций
Цель: Обеспечить целостность данных при выполнении операций.
Сценарий:  
Реализовать следующую логику в виде SQL-транзакции:
- Клиент оформляет заказ, который включает в себя:
	1. Создание новой записи в таблице orders с текущей датой.
	2. Добавление 3–5 случайных товаров в таблицу order_items для созданного заказа.
	3. В случае любой ошибки (например, попытка вставить NULL в product_name), вся транзакция откатывается.  
Требование:
	- Использовать явное начало/конец транзакции (BEGIN, COMMIT, ROLLBACK).
	- Обработать возможные ошибки.
	- Продемонстрировать, что в случае сбоя никаких частичных данных не остаётся в базе.  
